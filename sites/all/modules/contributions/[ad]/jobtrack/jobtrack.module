<?php
// $Id: jobtrack.module,v 1.1.2.5 2009/01/25 11:11:36 jeremy Exp $

/**
 * @file jobtrack.module
 */

/**
 * Implementation of hook_node_info().
 */
function jobtrack_node_info() {
  return array(
    'jobtrack_ticket' => array(
      'name' => t('Job ticket'),
      'module' => 'jobtrack',
      'description' => t('A <em>jobtrack ticket</em> is a ticket for a job.'),
    ),
  );
}

/**
 * Implementation of hook_acces().
 */
function jobtrack_access($op, $node, $account) {
  switch ($op) {
    case 'create':
      return user_access('create tickets', $account);
  }
}

/**
 * Implementation of hook_menu().
 */
function jobtrack_menu() {
  $items['jobtrack'] = array(
    'title' => 'Job tickets',
    'page callback' => 'jobtrack_page',
    'page arguments' => array(),
    'access callback' => 'jobtrack_access_clients',
    'access arguments' => array(),
  );
  // TODO: Figure out how to use the 6.x menu system correctly, this feels a
  // little sloppy.
  $result = db_query('SELECT clid, path, name FROM {jobtrack_client} WHERE status = 1');
  while ($client = db_fetch_object($result)) {
    $items["jobtrack/$client->path"] = array(
      'title' => "$client->name",
      'page callback' => 'jobtrack_page',
      'page arguments' => array($client->clid),
      'access callback' => 'jobtrack_access_clients',
      'access arguments' => array($client, TRUE),
    );
    $states = array('all' => 'all', 'all open' => 'all open') + _jobtrack_states();
    foreach ($states as $sid => $state) {
      $items["jobtrack/$client->path/$state"] = array(
        'title' => "$state",
        'page callback' => 'jobtrack_page',
        'page arguments' => array($client->clid, $state),
        'access callback' => 'jobtrack_access_clients',
        'access arguments' => array($client, TRUE),
        'weight' => $sid,
        'type' => $sid == 'all open' ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      );
    }
  }
  $items['jobtrack/user/%user_uid_optional'] = array(
    'page callback' => 'jobtrack_page_user',
    'page arguments' => array(2),
    'access callback' => 'jobtrack_page_user_access',
    'access arguments' => array(2),
    'type' => MENU_CALLBACK,
    'file' => 'jobtrack.user.inc',
  );
  $items['jobtrack/%user_uid_optional/assigned'] = array(
    'title' => 'My tickets',
    'page callback' => 'jobtrack_page_user',
    'page arguments' => array(1, TRUE),
    'access callback' => 'jobtrack_page_user_access',
    'access arguments' => array(1),
    'file' => 'jobtrack.user.inc',
  );
  $items['jobtrack/%node/unsubscribe/%user/%'] = array(
    'page callback' => 'jobtrack_unsubscribe_user',
    'page arguments' => array(1, 3, 4),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['jobtrack/all/unsubscribe/%user/%'] = array(
    'page callback' => 'jobtrack_unsubscribe_user',
    'page arguments' => array('all', 3, 4),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['admin/jobtrack'] = array(
    'title' => 'Job tracker',
    'description' => 'Manage the job tracker.',
    'position' => 'right',
    'weight' => 5,
    'page callback' => 'jobtrack_admin_menu_block_page',
    'access arguments' => array('access administration pages'),
    'file' => 'jobtrack.admin.inc',
  );
  $items['admin/jobtrack/clients'] = array(
    'title' => 'Clients',
    'description' => 'Manage clients.',
    'page callback' => 'jobtrack_admin_client_overview',
    'access arguments' => array('administer jobtrack'),
    'file' => 'jobtrack.admin.inc',
  );
  $items['admin/jobtrack/clients/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/jobtrack/clients/%jobtrack_client/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('jobtrack_admin_client', 3),
    'access arguments' => array('administer jobtrack'),
    'file' => 'jobtrack.admin.inc',
  );
  $items['admin/jobtrack/clients/%jobtrack_client/fetch'] = array(
    'title' => 'Fetch mail',
    'type' => MENU_CALLBACK,
    'page callback' => 'jobtrack_client_fetch',
    'page arguments' => array(3),
    'access arguments' => array('administer jobtrack'),
    'file' => 'jobtrack.admin.inc',
  );
  $items['admin/jobtrack/clients/add'] = array(
    'title' => 'Add client',
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('jobtrack_admin_client'),
    'access arguments' => array('administer jobtrack'),
    'file' => 'jobtrack.admin.inc',
  );
  $items['admin/jobtrack/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('jobtrack_admin_settings'),
    'access arguments' => array('administer jobtrack'),
    'file' => 'jobtrack.admin.inc',
  );
  return $items;
}

function jobtrack_cron() {
  $clients = jobtrack_active_clients();
  foreach ($clients as $clid => $client) {
    jobtrack_client_fetch($client, FALSE); 
  }
}

/**
 * Load all active clients.
 */
function jobtrack_active_clients() {
  static $clients = NULL;

  if (is_null($clients)) {
    $result = db_query('SELECT * FROM {jobtrack_client} WHERE status = 1');
    while ($client = db_fetch_object($result)) {
      $clients[$client->clid] = $client;
    }
  }
  return $clients;
}

/**
 * Unsubscribe user from tickets.
 */
function jobtrack_unsubscribe_user($node, $account, $key) {
  // unsubscribe from a single node
  if (is_object($node) && is_object($account)) {
    $lock = md5($account->uid . $node->nid);
    if ($key == $lock) {
      db_query('UPDATE {jobtrack_assigned} SET active = 0 WHERE uid = %d AND nid = %d', $account->uid, $node->nid);
      drupal_set_message(t('%email has been unsubscribed from ticket %ticket.', array('%email' => $account->mail, '%ticket' => $node->title)));
    }
    else {
      drupal_set_message(t('Invalid key, failed to unsubscribe %email.', array('%email' => $account->mail)), 'error');
    }
    drupal_goto("node/$node->nid");
  }
  else if (is_object($account)) {
    $lock = md5($account->uid);
    if ($key == $lock) {
      db_query('UPDATE {jobtrack_assigned} SET active = 0 WHERE uid = %d', $account->uid);
      drupal_set_message(t('%email has been unsubscribed from all tickets.', array('%email' => $account->mail)));
    }
    else {
      drupal_set_message(t('Invalid key, failed to unsubscribe %email.', array('%email' => $account->mail)), 'error');
    }
  }
  drupal_goto('');
}

/**
 * Custom permissions function.
 */
function jobtrack_access_clients($client = NULL) {
  if (is_object($client)) {
    return (user_access('administer jobtrack') || user_access("access $client->name tickets"));
  }
  else {
    return _jobtrack_access_tickets();
  }
}

/**
 * Menu callback, load a client.
 */
function jobtrack_client_load($clid) {
  static $clients = array();
  if (!isset($clients[$clid])) {
    $clients[$clid] = db_fetch_object(db_query('SELECT * FROM {jobtrack_client} WHERE clid = %d', $clid));
  }
  return $clients[$clid];
}

/**
 * Menu callback, load a ticket.
 */
function jobtrack_ticket_load($nid) {
  $tickets = array();
  if (!isset($tickets[$nid])) {
    $tickets[$nid] = db_fetch_object(db_query('SELECT * FROM {jobtrack_ticket} WHERE nid = %d', $nid));
  }
  return $tickets[$nid];
}

/**
 * Extract domains.
 */
function _jobtrack_domains($client, $global) {
  $domains = array();
  $string = "$client, $global";
  $raw = explode(',', $string);
  foreach ($raw as $domain) {
    if ($domain) {
      $domains[] = trim($domain);
    }
  }
  return $domains;
}

/**
 * Match up a user account with an incoming email.  Create account if email
 * doesn't match any.
 * TODO: Make it possible to assign multiple email addresses to one account.
 */
function jobtrack_account_load($from, $ticket, $subject) {
  $uid = db_result(db_query("SELECT uid FROM {users} WHERE mail = '%s'", $from));
  if ($uid) {
    return user_load($uid);
  }
  else {
    // extract the domain out of the from email address
    $matches = array();
    preg_match("/(.*)@(.*)/", $from, $matches);
    $domain = $matches[2];
    $ticket = jobtrack_ticket_load($ticket);
    $client = jobtrack_client_load($ticket->client);
    $domains = _jobtrack_domains($client->domains, variable_get('jobtrack_global_domains', ''));
    $valid = TRUE;
    if (!empty($domains)) {
      $valid = FALSE;
      foreach ($domains as $match) {
        if ($domain == $match) {
          $valid = TRUE;
        }
      }
    }
    // TODO: this isn't a role, this is a permission
    //$role = "access $client->name tickets";
    if ($valid) {
      watchdog('jobtrack', 'User !username automatically created.', array('!username' => $from), WATCHDOG_NOTICE);
      //return user_save(NULL, array('mail' => $from, 'init' => $from, 'name' => $from, 'status' => 1, 'roles' => array($role)));
      return user_save(NULL, array('mail' => $from, 'init' => $from, 'name' => $from, 'status' => 1));
    }
    else {
      $node = node_load($ticket);
      watchdog('jobtrack', 'Email update from !from denied for ticket "!title", subject "!subject."', array('!from' => $from, '!title' => $node->title, '!subject' => $subject), WATCHDOG_NOTICE);
      return FALSE;
    }
  }
}

/**
 *
 */
function jobtrack_client_name_load($name) {
  return db_fetch_object(db_query("SELECT * FROM {jobtrack_client} WHERE name = '%s'"));
}

/**
 * Implementation of hook_perm().
 */
function jobtrack_perm() {
  $perm = array('administer jobtrack', 'create tickets', 'edit own ticket', 'administer state', 'can suppress notification');
  $result = db_query('SELECT name FROM {jobtrack_client} WHERE status = 1');
  while ($client = db_fetch_object($result)) {
    $perm[] = "access $client->name tickets";
  }
  return $perm;
}

/**
 * Implementation of hook_user().
 */
function jobtrack_user($type, &$edit, &$user) {
  if ($type == 'view' && user_access('create tickets', $user)) {
    $user->content['summary']['jobtrack'] = array(
      '#type' => 'user_profile_item',
      '#title' => t('Tickets'),
      '#value' => l(t('View recent tickets'), "jobtrack/user/$user->uid", array('attributes' => array('title' => t("Read @username's latest tickets.", array('@username' => $user->name))))),
      '#attributes' => array('class' => 'jobtrack'),
    );
  }
}

/**
 * Implementation of hook_form().
 */
function jobtrack_form(&$node) {
  $type = node_get_types('type', $node);

  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => check_plain($type->title_label),
    '#required' => TRUE,
    '#default_value' => !empty($node->title) ? $node->title : NULL,
    '#weight' => -5,
  );

  $reference = array();
  $form = array_merge($form, jobtrack_status_form($reference, $node, ''));

  $form['body_field'] = node_body_field($node, $type->body_label, $type->min_word_count);

  $form = array_merge($form, jobtrack_subscribe_form($reference, $node, ''));

  return $form;

}

/**
 * Implementation of hook_nodeapi().
 */
function jobtrack_nodeapi(&$node, $op, $teaser, $page) {
  if ($node->type == 'jobtrack_ticket') {
    switch ($op) {
      case 'view':
        // viewing a ticket
        $breadcrumb = array();
        $breadcrumb[] = l(t('Home'), NULL);
        $breadcrumb[] = l(t('Job tickets'), 'jobtrack');
        if ($node->client) {
          $_SESSION['jobtrack_client'] = $node->client;
          $client = jobtrack_client_load($node->client);
          $breadcrumb[] = l($client->name, "jobtrack/$client->path");
        }
        drupal_set_breadcrumb($breadcrumb);
        break;
      case 'load':
        return db_fetch_array(db_query('SELECT state, priority, client, assigned FROM {jobtrack_ticket} WHERE nid = %d', $node->nid));
      case 'validate':
        if (!$node->client) {
          form_set_error('client', t('You must select a client'));
        }
        break;
      case 'insert':
      case 'update':
        db_query('UPDATE {jobtrack_ticket} SET state = %d, priority = %d, client = %d, assigned = %d WHERE nid = %d', $node->state, $node->priority, $node->client, $node->assigned, $node->nid);
        if (!db_affected_rows()) {
          db_query('INSERT INTO {jobtrack_ticket} (nid, state, priority, client, assigned) VALUES(%d, %d, %d, %d, %d)', $node->nid, $node->state, $node->priority, $node->client, $node->assigned);
        }
        if ($op == 'insert') {
          // auto-subscribe configured users
          _jobtrack_autosubscribe($node->nid, $node->client);
          // auto-subscribe ticket creator
          jobtrack_subscribe_user($node->nid, $node->uid, $node->notification);
          // generate notification emails
          jobtrack_notification(0, $node->nid, 'ticket_new', $node->suppress);
        }
        cache_clear_all();
        break;
      case 'delete':
        db_query('DELETE FROM {jobtrack_ticket} WHERE nid = %d', $node->nid);
        break;
    }
  }
}

/**
 * Implementation of hook_comment().
 */
function jobtrack_comment(&$comment, $op) {
  global $user;

  switch ($op) {
    case 'view':
      jobtrack_comment_view($comment);
      break;
    case 'insert':
    case 'update':
      db_query('UPDATE {jobtrack_ticket_comment} SET state = %d, priority = %d, client = %d, assigned = %d WHERE cid = %d', $comment['state'], $comment['priority'], $comment['client'], $comment['assigned'], $comment['cid']);
      if (!db_affected_rows()) {
        db_query('INSERT INTO {jobtrack_ticket_comment} (cid, state, priority, client, assigned) VALUES(%d, %d, %d, %d, %d)', $comment['cid'], $comment['state'], $comment['priority'], $comment['client'], $comment['assigned']);
      }
      _jobtrack_comment_update_node($comment['nid']);
      if ($op == 'insert') {
        // auto-subscribe configured users
        _jobtrack_autosubscribe($comment['nid'], $comment['client']);
        // auto-subscribe ticket-comment creator
        jobtrack_subscribe_user($comment['nid'], $comment['uid'], $comment['notification']);
        // auto-subscribe assigned user
        if ($comment['assigned']) {
          jobtrack_subscribe_user($comment['nid'], $comment['assigned']);
        }
        // generate notification emails
        jobtrack_notification($comment['cid'], $comment['nid'], 'ticket_comment_new', $comment['suppress']);
      }
      // if admin, can update who is assignd to the ticket
      if (user_access('administer jobtrack') && !$comment['jobtrack_email']) {
        $node = node_load($comment['nid']);
        $available = _jobtrack_assigned(0, $node);
        foreach ($available as $uid => $name) {
          if (!$uid || $user->uid == $uid) continue;
          jobtrack_subscribe_user($node->nid, $uid, $comment["notify-$uid"]);
        }
      }
      break;
    case 'delete':
      db_query('DELETE FROM {jobtrack_ticket_comment} WHERE cid = %d', $comment->cid);
      _jobtrack_comment_update_node($comment->nid);
  }
}

/**
 * Display state, priority and client when viewing comments for jobtrack nodes.
 */
function jobtrack_comment_view(&$comment) {
  static $state = 0;
  static $priority = 0;
  static $client = 0;
  static $assigned = 0;
  $current = db_fetch_object(db_query('SELECT state, priority, client, assigned FROM {jobtrack_ticket_comment} WHERE cid = %d', $comment->cid));
  if ($assigned != $current->assigned) {
    $previous_account = user_load(array('uid' => $assigned));
    $current_account = user_load(array('uid' => $current->assigned));
    $comment->comment = '<div class="jobtrack-assigned">Assigned: '. ($previous_account->name ? $previous_account->name : '<em>'. t('unassigned') .'</em>') .' -> '. ($current_account->name ? $current_account->name : '<em>'. t('unassigned') .'</em>') ."</div>\n". $comment->comment;
    $assigned = $current->assigned;
  }
  if ($client != $current->client) {
    $comment->comment = '<div class="jobtrack-client">Client: '. _jobtrack_client($client) .' -> '. _jobtrack_client($current->client) ."</div>\n". $comment->comment;
    $client = $current->client;
  }
  if ($state != $current->state) {
    $comment->comment = '<div class="jobtrack-state">State: '. _jobtrack_state($state) .' -> '. _jobtrack_state($current->state) ."</div>\n" . $comment->comment;
    $state = $current->state;
  }
  if ($priority != $current->priority) {
    $comment->comment = '<div class="jobtrack-priority">Priority: '. _jobtrack_priorities($priority) .' -> '. _jobtrack_priorities($current->priority) ."</div>\n" . $comment->comment;
    $priority = $current->priority;
  }
}

/**
 * Implementation of hook_mail().
 */
function jobtrack_mail($key, &$message, $params) {
  $language = $message['language'];
  $variables = jobtrack_mail_tokens($params['account'], $language, $params['nid'], $params['cid'], $params['suppress']);
  $message['subject'] .= _jobtrack_mail_text($key .'_subject', $language, $variables);
  $message['body'] = _jobtrack_mail_text($key .'_body', $language, $variables);
}

/**
 * Return an array of token to value mappings for jobtrack e-mail messages.
 */
function jobtrack_mail_tokens($account, $language, $nid, $cid, $suppress) {
  global $base_url;
  static $reset = TRUE;
  // force reload node from database to get updated state/priority information,
  // but no need to reset it multiple times when sending multiple notifications
  $node = node_load($nid, NULL, $reset);
  $reset = FALSE;
  $comment = _comment_load($cid);
  $update_account = $comment->uid ? user_load($comment->uid) : user_load($node->uid);
  $ticket_unsubscribe_key = md5($account->uid . $node->nid);
  $all_unsubscribe_key = md5($account->uid);
  $previous_comment = db_result(db_query_range('SELECT cid FROM {comments} WHERE nid = %d ORDER BY cid DESC', $nid, 1, 1));
  if ($previous_comment) {
    $previous = db_fetch_object(db_query('SELECT * FROM {jobtrack_ticket_comment} WHERE cid = %d', $previous_comment));
  }
  $tokens = array(
    '!username' => $account->name,
    '!key' => '['. variable_get('jobtrack_key', 'tkt') .":$nid]",
    '!update_username' => $update_account->name,
    '!site' => variable_get('site_name', 'Drupal'),
    '!uri' => $base_url,
    '!uri_brief' => preg_replace('!^https?://!', '', $base_url),
    '!mailto' => $account->mail,
    '!date' => format_date(time(), 'medium', '', NULL, $language->language),
    '!ticket_subject' => $node->title,
    '!ticket_body' => $suppress ? t('The text of this ticket was manually suppressed.  You must view the ticket online to see it.') : $node->body,
    '!ticket_url' => url("node/$nid", array('absolute' => TRUE, 'language' => $language, 'fragment' => "comment-$cid")),
    '!update_url' => url("node/$nid", array('absolute' => TRUE, 'language' => $language, 'fragment' => "comment-form")),
    '!update' => $suppress ? t('The text of this ticket update was manually suppressed.  You must view the ticket online to see the update.') : $comment->comment,
    '!state' => ((isset($previous->state) && $previous->state != $node->state) ? _jobtrack_state($previous->state) .' -> ' : '') . _jobtrack_state($node->state),
    '!priority' => ((isset($previous->priority) && $previous->priority != $node->priority) ? _jobtrack_priorities($previous->priority) .' -> ' : '') . _jobtrack_priorities($node->priority),
    '!unsubscribe_ticket' => url("jobtrack/$nid/unsubscribe/$account->uid/$ticket_unsubscribe_key", array('absolute' => TRUE, 'language' => $language)),
    '!unsubscribe_all' => url("jobtrack/all/unsubscribe/$account->uid/$all_unsubscribe_key", array('absolute' => TRUE, 'language' => $language)),
  );
  if (!empty($account->password)) {
    $tokens['!password'] = $account->password;
  }
  return $tokens;
}

/**
 * Returns the appropriate mail string for a given key.
 */
function _jobtrack_mail_text($key, $language = NULL, $variables = array()) {
  $langcode = isset($language) ? $language->language : NULL;

  if ($admin_setting = variable_get('jobtrack_mail_'. $key, FALSE)) {
    // An admin setting overrides the default string.
    return strtr($admin_setting, $variables);
  }
  else {
    // No override, return default string.
    switch ($key) {
      case 'ticket_new_subject':
        return t("!key !ticket_subject", $variables, $langcode);
      case 'ticket_new_body':
        return t("!update_username has created the ticket '!ticket_subject':\n!ticket_url\n\nState: !state\nPriority: !priority\n\nYou can reply to this email (do not modify the subject) or visit the following URL to update this ticket:\n!update_url\n\nTicket text:\n------------------------------\n!ticket_body\n------------------------------\n\nUnsubscribe from this ticket:\n!unsubscribe_ticket\n\nUnsubscribe from all tickets:\n!unsubscribe_all", $variables, $langcode);
      case 'ticket_comment_new_subject':
        return t("!key !ticket_subject", $variables, $langcode);
      case 'ticket_comment_new_body':
        return t("!update_username has updated the ticket '!ticket_subject':\n!ticket_url\n\nState: !state\nPriority: !priority\n\nYou can reply to this email (do not modify the subject) or visit the following URL to update this ticket:\n!update_url\n\nUpdate text:\n------------------------------\n!update\n------------------------------\n\nUnsubscribe from this ticket:\n!unsubscribe_ticket\n\nUnsubscribe from all tickets:\n!unsubscribe_all", $variables, $langcode);
    }
  }
}

/**
 * Save the message.
 */
function jobtrack_save_message($subject, $body, $from, $ticket, $client) {
  $account = jobtrack_account_load($from, $ticket, $subject);
  $ticket = jobtrack_ticket_load($ticket);
  if (is_object($account) && is_object($ticket) && $ticket->nid) {
    // by retrieving the maximum thread level.
    $max = db_result(db_query('SELECT MAX(thread) FROM {comments} WHERE nid = %d', $ticket->nid));
    // Strip the "/" from the end of the thread.
    $max = rtrim($max, '/');
    // Finally, build the thread field for this new comment.
    $thread = int2vancode(vancode2int($max) + 1) .'/';
    // TODO: format?
    // TODO: ip_address?
    db_query("INSERT INTO {comments} (nid, pid, uid, subject, comment, format, hostname, timestamp, status, thread, name, mail, homepage) VALUES (%d, %d, %d, '%s', '%s', %d, '%s', %d, %d, '%s', '%s', '%s', '%s')", $ticket->nid, 0, $account->uid, $subject, $body, 1, ip_address(), time(), 0, $thread, $account->name, $account->mail, $account->homepage);

    // Tell the other modules a new comment has been submitted.
    $comment['cid'] = db_last_insert_id('comments', 'cid');
    $comment['subject'] = $subject;
    $comment['comment'] = $body;
    $comment['nid'] = $ticket->nid;
    $comment['uid'] = $account->uid;
    $comment['state'] = $ticket->state;
    $comment['priority'] = $ticket->priority;
    $comment['client'] = $ticket->client;
    $comment['assigned'] = $ticket->assigned;
    $comment['notification'] = db_result(db_query('SELECT active FROM {jobtrack_assigned} WHERE nid = %d AND uid = %d', $ticket->nid, $account->uid));
    $comment['jobtrack_email'] = TRUE;
    comment_invoke_comment($comment, 'insert');

    // Add an entry to the watchdog log.
    watchdog('content', 'Comment: added %subject.', array('%subject' => $comment['subject']), WATCHDOG_NOTICE, l(t('view'), 'node/'. $comment['nid'], array('fragment' => 'comment-'. $comment['cid'])));
    _comment_update_node_statistics($comment['nid']);

    // Clear the cache so an anonymous user can see his comment being added.
    cache_clear_all();
    return TRUE;
  }
  else if (is_object($account)) {
    // Create new ticket if none matches and valid from address.
    $node->title = $subject;
    $node->body = $body;
    $node->type = 'jobtrack_ticket';
    $node->log = t('Jobtrack ticket created from email.');
    $node->comment = COMMENT_NODE_READ_WRITE;
    $node->uid = $account->uid;
    $node->state = _jobtrack_state_default();
    $node->priority = _jobtrack_priority_default();
    $node->client = $client->clid;
    $node->notification = TRUE;
    $node->jobtrack_email = TRUE;
    node_save($node);
  }
}

function _jobtrack_get_message_body($stream, $message, $structure, $part = 1) {
  if (!empty($structure)) {
    $body = imap_fetchbody($stream, $message, $part);
    foreach ($structure->parameters as $parameter) {
      if (strtoupper($parameter->attribute) == 'CHARSET') {
        $encoding = $parameter->value;
        break;
      }
    }
    switch ($structure->encoding) {
      case 3: // base64
        $decoded = drupal_convert_to_utf8(imap_base64($body), $encoding);
        break;
      case 4: // quoted-printable
        $decoded = drupal_convert_to_utf8(quoted_printable_decode($body), $encoding);
        break;
      default:
        $decoded = drupal_convert_to_utf8($body, $encoding);
        break;
    }

    if ($decoded) {
      return ($decoded);
    }
    else {
      watchdog('jobtrack', t("Failed to convert message to utf8 -- using unconverted message.  To fix this, try installing iconv, GNU recode, or mbstring for PHP."));
      return ($body);
    }

  }
  return NULL;
}

/**
 * Subscribe a user to a ticket.
 */
function jobtrack_subscribe_user($nid, $uid, $active = 1) {
  db_query('UPDATE {jobtrack_assigned} SET active = %d WHERE uid = %d AND nid = %d', $active, $uid, $nid);
  if (!db_affected_rows()) {
    db_query('INSERT INTO {jobtrack_assigned} (nid, uid, active) VALUES(%d, %d, %d)', $nid, $uid, $active);
  }
}

/**
 * Autosubscribe users to new client ticket.
 */
function _jobtrack_autosubscribe($nid, $client) {
  $autosubscribe = db_result(db_query('SELECT autosubscribe FROM {jobtrack_client} WHERE clid = %d', $client));
  $autosubscribe = explode(',', $autosubscribe);
  foreach ($autosubscribe as $name) {
    $account = user_load(array('name' => trim($name)));
    if (is_object($account) && $account->uid) {
      jobtrack_subscribe_user($nid, $account->uid);
    }
  }
}

/**
 * Send notification emails to everyone subscribed to the updated ticket.
 */
function jobtrack_notification($cid, $nid, $op = 'ticket_comment_new', $suppress = FALSE) {
  $result = db_query('SELECT uid FROM {jobtrack_assigned} WHERE nid = %d AND active = 1', $nid);
  while ($account = db_fetch_object($result)) {
    $account = user_load(array('uid' => $account->uid));
    // always send emails to admins, even if update was suppressed
    if (!$suppress || user_access('administer jobtrack', $account)) {
      _jobtrack_mail_notify($op, $account, $cid, $nid, $suppress);
    }
  }
}

/**
 * Use drupal_mail to send email.
 */
function _jobtrack_mail_notify($op, $account, $cid = NULL, $nid = NULL, $suppress = FALSE, $language = NULL) {
  $notify = variable_get('jobtrack_mail_'. $op .'_notify', TRUE);
  if ($notify) {
    $node = node_load($nid);
    $mailfrom = db_result(db_query('SELECT mailfrom FROM {jobtrack_client} WHERE clid = %d', $node->client));
    $params['account'] = $account;
    $params['nid'] = $nid;
    $params['cid'] = $cid;
    $params['suppress'] = $suppress;
    $language = $language ? $language : user_preferred_language($account);
    $mail = drupal_mail('jobtrack', $op, $account->mail, $language, $params, $mailfrom);
    // TODO: notify admins as necessary
  }
  return empty($mail) ? NULL : $mail['result'];
}

/**
 * Helper function.
 */
function _jobtrack_comment_update_node($nid) {
  $cid = db_result(db_query('SELECT MAX(cid) FROM {comments} WHERE nid = %d', $nid));
  if ($cid) {
    $comment = db_fetch_object(db_query('SELECT state, priority, client, assigned FROM {jobtrack_ticket_comment} WHERE cid = %d', $cid));
    db_query('UPDATE {jobtrack_ticket} SET state = %d, priority = %d, client = %d, assigned = %d WHERE nid = %d', $comment->state, $comment->priority, $comment->client, $comment->assigned, $nid);
  }
}

/**
 * Customize comment form for ticket followups.
 */
function jobtrack_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'comment_form') {
    $reference = array();
    $form = array_merge(jobtrack_status_form($form_state, $form, ''), $form);
    $form = array_merge($form, jobtrack_subscribe_form($reference, $form, ''));
  }
}

/**
 * Generate form for adding update to ticket.  Enhances comment_form.
 */
function jobtrack_status_form(&$form_state, $edit, $title) {
  $cid = 0;
  if (is_array($edit)) {
    if (is_array($edit['nid'])) {
      $node = node_load($edit['nid']['#value']);
      $cid = $edit['cid']['#value'];
    }
    else {
      $node = node_load($edit['nid']);
    }
  }
  else if (is_object($edit)) {
    $node = node_load($edit->nid);
  }
  if ($cid) {
    $comment = db_fetch_object(db_query('SELECT state, priority FROM {jobtrack_ticket_comment} WHERE cid = %d', $cid));
    if ($comment->state && $comment->priority) {
      $node->state = $comment->state;
      $node->priority = $comment->priority;
    }
  }
  $form['jobtrack'] = array(
    '#type' => 'fieldset',
    '#prefix' => '<div class="container-inline">',
    '#suffix' => '</div>',
  );
  $form['jobtrack']['state'] = array(
    '#type' => 'select',
    '#title' => t('State'),
    '#options' => _jobtrack_states(FALSE, $node->state),
    '#default_value' => $node->state ? $node->state : _jobtrack_state_default(),
  );
  $form['jobtrack']['space'] = array(
    '#value' => '&nbsp;&nbsp;',
  );
  $form['jobtrack']['priority'] = array(
    '#type' => 'select',
    '#title' => t('Priority'),
    '#options' => _jobtrack_priorities(),
    '#default_value' => $node->priority ? $node->priority : _jobtrack_priority_default(),
  );
  $form['jobtrack']['space2'] = array(
    '#value' => '&nbsp;&nbsp;',
  );
  $clients = _jobtrack_available_clients();
  if (sizeof($clients) == 1) {
    foreach ($clients as $key => $name) {
      $client = $key;
    }
    $node->client = $client;
  }
  else {
    $clients = array(0 => '- select client -') + $clients;
    if (isset($_SESSION['jobtrack_client']) && $_SESSION['jobtrack_client']) {
      $node->client = $_SESSION['jobtrack_client'];
    }
  }
  $form['jobtrack']['client'] = array(
    '#type' => 'select',
    '#required' => TRUE,
    '#title' => t('Client'),
    '#options' => $clients,
    '#default_value' => $node->client ? $node->client : 0,
  );
  $form['jobtrack']['space3'] = array(
    '#value' => '&nbsp;&nbsp;',
  );
  $form['jobtrack']['assigned'] = array(
    '#type' => 'select',
    '#title' => t('Assigned'),
    '#options' => _jobtrack_assigned($node->assigned, $node),
    '#default_value' => $node->assigned ? $node->assigned : 0,
  );
  return $form;
}

/**
 * Get list of available users to assign ticket to.
 */
function _jobtrack_assigned($assigned, $node) {
  global $user;

  $available = array();

  // can only unassign tickets if assigned to self, or have admin permissions
  if (!$assigned || $assigned == $user->uid || 
      user_access('administer jobtrack')) {
    $available[0] = ' - '. t('not assigned') .' -';
  }

  if ($assigned && $assigned != $user->uid) {
    $account = user_load($assigned);
    $available[$account->uid] = $account->name;
  }

  // can always re-assign ticket to self
  $available[$user->uid] = $user->name;

  if ($node->client && user_access('administer jobtrack')) {
    $roles = array();
    $client = db_result(db_query('SELECT name FROM {jobtrack_client} WHERE clid = %d', $node->client));
    // retrieve all roles giving permission to access current tickets
    $result = db_query("SELECT rid FROM {permission} WHERE perm LIKE '%%%s%%' OR perm LIKE '%%%s%%'", "access $client tickets", 'administer jobtrack');
    while ($role = db_fetch_object($result)) {
      $roles[$role->rid] = $role->rid;
    }
    // retrieve all users in appropriate roles
    $accounts = array();
    $all = FALSE;
    foreach ($roles as $rid) {
      if ($rid == DRUPAL_AUTHENTICATED_RID) {
        $all = TRUE;
        $result = db_query('SELECT uid FROM {users} WHERE status = 1');
      }
      else {
        $result = db_query('SELECT r.uid FROM {users_roles} r LEFT JOIN {users} u ON r.uid = u.uid WHERE r.rid = %d AND u.status = 1', $rid);
      }
      while ($account = db_fetch_object($result)) {
        $accounts[$account->uid] = $account->uid;
      }
      // we've already retrieved all active users, no need to search more roles
      if ($all) break;
    }
    // load users and allow them to be assigned
    foreach ($accounts as $uid) {
      $account = user_load(array('uid' => $uid));
      $available[$account->uid] = $account->name;
    }
  }

  return $available;
}

/**
 * Provide option to subscribe/unsubscribe from ticket notification emails.
 */
function jobtrack_subscribe_form(&$form_state, $edit, $title) {
  global $user;
  $form = array();
  $form['subscribe'] = array(
    '#type' => 'fieldset',
    '#title' => t('Notifications'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  if (is_array($edit)) {
    $notification = db_result(db_query('SELECT active FROM {jobtrack_assigned} WHERE nid = %d AND uid = %d', $edit['nid']['#value'], $user->uid));
  }
  else {
    $notification = TRUE;
  }
  $form['subscribe']['notification'] = array(
    '#type' => 'checkbox',
    '#title' => t('Subscribe'),
    '#description' => t('Receive email notifications when this ticket is updated.'),
    '#default_value' => isset($notification) ? $notification : TRUE,
  );
  if (user_access('can suppress notification')) {
    $form['subscribe']['suppress'] = array(
      '#type' => 'checkbox',
      '#title' => t('Suppress notification'),
      '#description' => t('By checking this box you will prevent notification emails from being sent for this ticket update.  It is recommended that you check this box if you are adding sensitive information such as passwords which should not be mailed out in plain text.'),
    );
  }
  if (is_array($edit) && user_access('administer jobtrack')) {
    $form['subscribe']['subscribed'] = array(
      '#type' => 'fieldset',
      '#title' => t('Subscribed'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
    $node = node_load($edit['nid']['#value']);
    $available = _jobtrack_assigned(0, $node);
    foreach ($available as $uid => $name) {
      if (!$uid) continue;
      $enabled = db_result(db_query('SELECT active FROM {jobtrack_assigned} WHERE nid = %d AND uid = %d', $node->nid, $uid));
      $form['subscribe']['subscribed']["notify-$uid"] = array(
        '#type' => 'checkbox',
        '#title' => $name,
        '#default_value' => $enabled,
        '#disabled' => $uid == $user->uid ? TRUE : FALSE,
      );
    }
  }
  return $form;
}

/**
 * Load all active clients.
 */
function _jobtrack_clients_load($path = FALSE) {
  $result = db_query('SELECT clid, path, name FROM {jobtrack_client} WHERE status = 1 ORDER BY name');
  while ($client = db_fetch_object($result)) {
    if ($path) {
      $clients[$client->clid] = $client->path;
    }
    else {
      $clients[$client->clid] = $client->name;
    }
  }
  return $clients;
}

/**
 * Access callback for user jobtrack ticket pages.
 */
function jobtrack_page_user_access($account) {
  return $account->uid && user_access('access content') && (user_access('create tickets', $account) || _jobtrack_ticket_exists($account));
}

/**
 * Helper function to list available states.
 */
function _jobtrack_states($all = TRUE, $sid = NULL) {
  static $states = array();
  $admin = user_access('administer state');

  if (!isset($states["$admin-$all-$sid"])) {
    if ($admin || $all) {
      $result = db_query("SELECT sid, state FROM {jobtrack_states} ORDER BY weight");
    }
    else if (!$all && !$sid) {
      $result = db_query("SELECT sid, state FROM {jobtrack_states} WHERE phase1 = 1 ORDER BY weight");
    }
    else if (!$all) {
      $result = db_query("SELECT sid, state FROM {jobtrack_states} WHERE phase2 = 1 ORDER BY weight");
    }
    while ($state = db_fetch_object($result)) {
      $states["$admin-$all-$sid"][$state->sid] = $state->state;
    }
    // include the current state, even if user doesn't actually have access
    if ($sid && !in_array($sid, $states["$admin-$all-$sid"])) {
      $states["$admin-$all-$sid"][$sid] = db_result(db_query("SELECT state FROM {jobtrack_states} WHERE sid = %d", $sid));
    }
  }

  return $states["$admin-$all-$sid"];
}

/**
 * Return default sid.
 */
function _jobtrack_state_default() {
  static $default = NULL;
  if (!$default) {
    $default = db_result(db_query_range('SELECT sid FROM {jobtrack_states} WHERE isdefault = 1', 0, 1));
  }
  return $default;
}

/**
 * Helper function to list available priorities.
 */
function _jobtrack_priorities($pid = NULL) {
  static $priorities = array();

  if (empty($priorities)) {
    $result = db_query('SELECT pid, priority FROM {jobtrack_priority} ORDER BY weight');
    while ($priority = db_fetch_object($result)) {
      $priorities[$priority->pid] = $priority->priority;
    }
  }

  if ($pid && isset($priorities[$pid])) {
    return $priorities[$pid];
  }
  if ($pid === 0) {
    return '';
  }
  else {
    return $priorities;
  }
}

/**
 * Return default pid.
 */
function _jobtrack_priority_default() {
  static $default = NULL;
  if (!$default) {
    $default = db_result(db_query_range('SELECT pid FROM {jobtrack_priority} WHERE isdefault = 1', 0, 1));
  }
  return $default;
}

/**
 * Helper function to determine if a user has jobtrack tickets already.
 */
function _jobtrack_ticket_exists($account) {
  return (bool)db_result(db_query_range(db_rewrite_sql("SELECT 1 FROM {node} n WHERE n.type = 'jobtrack_ticket' AND n.uid = %d AND n.status = 1"), $account->uid, 0, 1));
}

/**
 * Helper function, retrieve state name from database.
 */
function _jobtrack_state($state) {
  static $state_name = array();

  if (!isset($state_name[$state])) {
    $state_name[$state] = db_result(db_query('SELECT state FROM {jobtrack_states} WHERE sid = %d', $state));
  }

  return $state_name[$state];
}

/**
 * Find all clients we have permission to view/edit.
 */
function _jobtrack_available_clients() {
  static $valid = array();

  if (empty($valid)) {
    $clients = _jobtrack_clients_load();
    foreach ($clients as $clid => $name) {
      if (user_access('administer jobtrack') || user_access("access $name tickets")) {
        $valid[$clid] = $name;
      }
    }
  }
  return $valid;
}

/**
 *
 */
function _jobtrack_get_state($state) {
  if ($state == 'all') {
    return 0;
  }
  else if ($state == 'all open') {
    return -1;
  }
  $sid = db_result(db_query("SELECT sid FROM {jobtrack_states} WHERE state = '%s'", $state));
  if (!$sid) {
    $sid = _jobtrack_state_default();
  }
  return $sid;
}

function _jobtrack_truncate($text, $maxlen = 64) {
  if (strlen($text) > $maxlen) {
    return substr($text, 0, $maxlen - 1) .'...';
  }
  return $text;
}

/**
 * Display tickets
 */
function jobtrack_page($client = NULL, $state = NULL) {
  global $user;

  if (!$client) {
    if (isset($_SESSION['jobtrack_client']) && $client = jobtrack_client_load($_SESSION['jobtrack_client'])) {
      drupal_goto("jobtrack/$client->path");
    }
    $clients = _jobtrack_available_clients();
    if (sizeof($clients)) {
      foreach ($clients as $key => $name) {
        $client = jobtrack_client_load($key);
        drupal_goto("jobtrack/$client->path");
      }
    }
  }
  else {
    $_SESSION['jobtrack_client'] = $client;
  }


  if (!$state) {
    $state = 'all open';
  }
  $state = _jobtrack_get_state($state);

  $rows = array();
  $header = array(
    array('data' => t('Ticket'), 'field' => 'n.title'),
    array('data' => t('Updated'), 'field' => 'last_updated', 'sort' => 'desc'),
    array('data' => t('Reported by'), 'field' => 'n.uid'),
    array('data' => t('Assigned to'), 'field' => 't.assigned'),
    array('data' => t('State'), 'field' => 't.state'),
    array('data' => t('Prioriy'), 'field' => 't.priority'),
    array('data' => t('Updates'), 'field' => 'l.comment_count'),
  );
  if ($state < 0) {
    // TODO: Make this configurable.
    $state = 'AND t.state != '. _jobtrack_get_state('closed');
  }
  else {
    $state = $state ? "AND t.state = $state" : '';
  }
  $sql = "SELECT DISTINCT(n.nid), n.title, n.type, n.changed, n.uid, u.name, GREATEST(n.changed, l.last_comment_timestamp) AS last_updated, l.comment_count, t.state, t.priority, t.assigned FROM {node} n LEFT JOIN {jobtrack_ticket} t ON n.nid = t.nid INNER JOIN {node_comment_statistics} l ON n.nid = l.nid INNER JOIN {users} u ON n.uid = u.uid LEFT JOIN {comments} c ON n.nid = c.nid WHERE (c.status = ". COMMENT_PUBLISHED ." OR c.status IS NULL) AND n.status = 1 AND client = $client $state";
  $sql = db_rewrite_sql($sql);
  $sql .= tablesort_sql($header);
  $sql_count = "SELECT COUNT(DISTINCT(n.nid)) FROM {node} n LEFT JOIN {comments} c ON n.nid = c.nid AND (c.status = %d OR c.status IS NULL) WHERE n.status = 1 AND client = $client $state";
  $sql_count = db_rewrite_sql($sql_count);
  $result = pager_query($sql, 50, 0, $sql_cont);
  $rows = array();
  while ($ticket = db_fetch_object($result)) {
    $account = user_load(array('uid' => $ticket->uid));
    $assigned = user_load(array('uid' => $ticket->assigned));
    $comments = l($ticket->comment_count, "node/$ticket->nid", array('fragment' => 'comments'));
    if ($new = comment_num_new($ticket->nid)) {
      $node = node_load($ticket->nid);
      $comments .= '&nbsp;('. l(format_plural($new, '1 new', '@count new'), "node/$ticket->nid", array('query' => comment_new_page_count($node->comment_count, $new, $node), 'fragment' => 'new')) .')';
    }
    $rows[] = array('data' => array(
      array('data' => l(_jobtrack_truncate($ticket->title), "node/$ticket->nid")),
      array('data' => format_date($ticket->last_updated, 'small')),
      array('data' => l(_jobtrack_truncate($account->name, 24), "user/$account->uid")),
      array('data' => l(_jobtrack_truncate($assigned->name, 24), "user/$assigned->uid")),
      array('data' => _jobtrack_state($ticket->state)),
      array('data' => _jobtrack_priorities($ticket->priority)),
      array('data' => $comments)), 'class' => "state-$ticket->state priority-$ticket->priority");
  }
  return theme('table', $header, $rows, array('class' => 'jobtrack'));
}

/**
 * Helper function, retrieve client name from database.
 */
function _jobtrack_client($clid) {
  static $client_name = array();

  if (!isset($client_name[$clid])) {
    $client_name[$clid] = db_result(db_query('SELECT name FROM {jobtrack_client} WHERE clid = %d', $clid));
  }

  return $client_name[$clid];
}

/**
 * Fetch mail for a specific client.
 */
function jobtrack_client_fetch($client, $manual = TRUE) {
  set_time_limit(0);
  if ($manual) {
    drupal_set_message(t('Fetching mail for !client...', array('!client' => $client->name)));
  }

  $connect = '{'. $client->server_name .':'. $client->port;
  $username = $client->server_username;
  $password = $client->server_password;
  switch ($client->protocol) {
    case 0: // POP3
      $connect .= '/pop3/novalidate-cert}'. $client->mailbox;
      break;
    case 1: // POP3S
      $connect .= '/pop3/ssl/novalidate-cert}'. $client->mailbox;
      break;
    case 2: // IMAP
      $connect .= '/novalidate-cert}'. $client->mailbox;
      break;
    case 3: // IMAPS
      $connect .= '/imap/ssl/novalidate-cert}'. $client->mailbox;
      break;
    case 4: // Local file
      $connect = $client->mailbox;
      $username = $password = '';
      // sanity tests
      if (!file_exists($connect) && $manual) {
        drupal_set_message(t('Mail file "%connect" does not exist.', array('%connect' => $connect)), 'error');
      }
      else if (!is_readable($connect) && $manual) {
        drupal_set_message(t('Mail file "%connect" is not readable.', array('%connect' => $connect)), 'error');
      }
      else if (!is_writable($connect) && $manual) {
        drupal_set_message(t('Mail file "%connect" is not writable.', array('%connect' => $connect)));
      }
      break;
  }

  // Make a connection to the mail server.
  $stream = imap_open($connect, $username, $password);
  if ($stream === FALSE) {
    drupal_set_message(t('Failed to download messages for %client, connection to mail server failed.', array('%client' => $client->name), 'error'));
    if ($alerts = imap_alerts()) {
      foreach ($alerts as $alert) {
        drupal_set_message(t('Imap alert: %alert>', array('%alert' => $alert)), 'error');
      }
    }
    if ($errors = imap_errors()) {
      foreach ($errors as $error) {
        drupal_set_message(t('Imap error: %error', array('%error' => $error)), 'error');
      }
    }
    return (-1);
  }

  $messages_downloaded = 0;
  // check how many messages are available
  $messages_to_download = imap_num_msg($stream);
  $messages_limit = variable_get('jobtrack_download_limit', 1000);
  if ($messages_limit && $messages_limit < $messages_to_download) {
    // TODO: watchdog, there are more messages available
    $messages_to_download = $messages_limit;
  }

  for ($message = 1; $message <= $messages_to_download; $message++) {
    $header = imap_headerinfo($stream, $message);

    if (is_array($header->from)) {
      $from = $header->from[0]->mailbox .'@'. $header->from[0]->host;
    }
    $subject = $header->subject;
    $key = variable_get('jobtrack_key', 'tkt');
    $tickets = array();
    preg_match("/(\[$key:)([0-9]*)(\])/", $subject, $tickets);
    $ticket = $tickets[2];

    $structure = imap_fetchstructure($stream, $message);
    $body = _jobtrack_get_message_body($stream, $message, $structure);

    $saved = jobtrack_save_message($subject, $body, $from, $ticket, $client);

    $messages_downloaded++;

    // mark message for deletion
    imap_delete($stream, $message);
  }
  imap_close($stream, CL_EXPUNGE);

  if ($manual) {
    drupal_goto('admin/jobtrack/clients');
  }
}

/**
 *
 */
function _jobtrack_access_tickets() {
  static $count = NULL;
  if (is_null($count)) {
    $count = 0;
    $result = db_query('SELECT name FROM {jobtrack_client} WHERE status = 1');
    while ($client = db_fetch_object($result)) {
      if (user_access('administer jobtrack') || user_access("access $client->name tickets")) {
        $count++;
      }
    }
  }
  return $count;
}
