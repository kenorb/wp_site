<?php
// $Id: game_message.module,v 1.1.2.1 2009/01/17 20:08:46 aaron Exp $

/**
 * @file
 * Provides an API for setting, storing, and displaying game messages.
 *  @TODO create block and page/[optional oid w/ perms] w/ recent messages for current active character or user.
 *  @TODO allow messages & associated message-oid objects older than x to be deleted on cron.
 *  @TODO allow message-oid objects to be deleted after display.
 *  @TODO provide link to delete individual message-oid objects.
 *  @TODO delete unassociated messages on cron.
 *  @TODO big red button to wipe all messages from database, with confirmation.
 *  @TODO tap into views.
 *  @TODO create a default view replicating block & block.
 */

/**
 *  Implements hook_menu().
 */
function game_message_menu() {
  module_load_include('inc', 'game_message', 'includes/game_message.menu');
  return _game_message_menu();
}

/**
 *  Implements hook_perm().
 */
function game_message_perm() {
  return array('administer game messages', 'view all game messages');
}

/**
 * Store displayable snippets about the games being played.
 *
 * @param $type
 *   The category to which this message belongs.
 * @param $message
 *   The message to store in the log.
 * @param $variables
 *   Array of variables to replace in the message.
 * @param $recipients
 *   Array of uids or nids that "own" this message.
 *   If game messages are set to users, then defaults to global user.
 *   If game messages are set to nodes, and the game_character module
 *   is installed, then defaults to the active character node.
 *   If any of the $recipients is 0, then this is a global message
 *   that will be displayed to all characters.
 */
function game_message($type, $message, $variables = array(), $recipients = array()) {
  if (count($recipients) == 0) {
    $oid = game_message_default_character_oid();
    if ($oid) {
      $recipients[] = $oid;
    }
  }

  // Don't save a message if there are no recipients.
  if (count($recipients) == 0) {
    return;
  }

  $message            = new stdClass();
  $message->type      = $type;
  $message->message   = $message;
  $message->variables = serialize($variables);
  $message->timestamp = time();
  drupal_write_record('game_messages', $log);

  // Associate this log record with all relevant characters. This is
  // necessary for 2+ player actions - each player should see the
  // relevant log entries generated by another character.
  foreach ($recipients as $oid) {
    $message_object = new stdClass();
    $message_object->oid = $oid;
    $message_object->lid = $message->lid;
    drupal_write_record('game_message_object', $message_object);
  }
}

/**
 * Return all game log activity for this user this page load.
 *
 * @param $uid
 *   The user ID to return logs for. Defaults to global user.
 * @param $from
 *   (optional, defaults to 0) Get messages from this count in the database.
 *   Useful for pager queries.
 * @param $limit
 *   (optional) The number of log messages to return. Defaults to 100.
 * @param $type
 *   (optional) If set, then retrieve messages only of this type.
 * @param $global
 *   (optional) If TRUE, then also retrieve any global (oid == 0) messages.
 * @return $recent_logs
 *   An array of log objects, sorted by descending log ID.
 */
function game_message_recent($oid = NULL, $from = 0, $limit = NULL, $type = NULL, $global = TRUE) {
  if (!$oid) {
    $oid = game_message_default_character_oid();
  }
  if (is_null($limit)) {
    $limit = variable_get('game_message_limit', 100);
  }
  $where = '(glu.oid = %d';
  $params = array($oid);
  if ($global) {
    $where .= ' OR glu.oid = 0';
  }
  $where .= ')';
  if (isset($type)) {
    $where .= " AND gl.type = '%s' ";
    $params[] = $type;
  }

  // There's no easy way we can determine "everything from this timestamp
  // forward, and the last hundred or so lines before that", so we'll just
  // accept a incoming $limit with a default of 100 rows.
  $results = db_query_range("SELECT gl.lid, gl.type, gl.message, gl.variables, gl.timestamp, glu.oid
    FROM {game_messages} gl INNER JOIN {game_message_user} glu ON (glu.lid = gl.lid) WHERE
    $where ORDER BY glu.lid DESC", $params, $from, $limit); // ASC'd below.
  while ($result = db_fetch_object($results)) {
    $recent_logs[] = $result;
  }

  // We get the last $limit entries by sorting by lid descending, but we still
  // want the earliest lid to be first when it comes to actual user display.
  return array_reverse($recent_logs);
}

/**
 *  Returns the default character uid or nid.
 *  This will either be $user->uid, or the active character $node->nid (if
 *  game_character is installed). Otherwise, it returns 0.
 *  @param $reset
 *    If TRUE, then reset the static variable.
 *  @return
 *    The $user->uid or $node->nid of the active character, or 0 if none.
 */
function game_message_default_character_oid($reset = FALSE) {
  static $oid;
  if ($reset || is_null($oid)) {
    $oid = 0;
    switch (variable_get('game_utility_character_objects', 'user')) {
      case 'node':
        if (module_exists('game_character')) {
          $active = game_character_get_active();
          $oid = $active->nid;
        }
        break;
      case 'user':
      default:
        global $user;
        $oid = $user->uid;
        break;
    }
  }
  return $oid;
}
