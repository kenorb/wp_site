<?php
// $Id: beautify.module,v 1.3.2.5 2009/02/01 12:15:18 psynaptic Exp $

/**
 * @file
 * HTML output processor for beautification, compacting and general processing.
 *
 * This module buffers the HTML output of Drupal and processes it through
 * HTML Tidy, htmLawed or a simple built-in function to beautify, flatten or
 * compact the HTML source code.
 *
 * It works with the cache system in that it sets the processed HTML to the
 * page cache.
 */

/**
 * Implementation of hook_menu().
 */
function beautify_menu() {
  $items = array();
  $items['admin/settings/beautify'] = array(
    'title' => 'Beautify',
    'description' => 'Configure settings for the processing of HTML output to the browser.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('beautify_settings'),
    'access arguments' => array('administer beautify')
  );

  return $items;
}

/**
 * Implementation of hook_perm().
 */
function beautify_perm() {
  return array(
    'administer beautify',
    'use beautify debug mode',
  );
}

/**
 * Implementation of hook_theme().
 */
function beautify_theme($existing, $type, $theme, $path) {
  return array('beautify_errors' => array('errors' => NULL));
}

/**
 * Admin settings form.
 */
function beautify_settings() {
  // Fetch an object with the options including defaults.
  $methods = beautify_methods();
  $form['beautify_enabled'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable output processing'),
    '#default_value' => variable_get('beautify_enabled', 1),
  );  
  $form['beautify_method'] = array(
    '#type' => 'radios',
    '#title' => t('Method'),
    '#options' => $methods->methods,
    '#default_value' => $methods->default,
  );
  $form['beautify_mode'] = array(
    '#type' => 'radios',
    '#title' => t('Mode'),
    '#options' => $methods->options,
    '#default_value' => $methods->mode,
  );

  // Advanced options.
  $form['options'] = array(
    '#type' => 'fieldset',
    '#title' => t('Advanced options'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  switch ($methods->default) {

    // HTML Tidy options
    case 'htmltidy':
      $form['options']['beautify_htmltidy_valid_xhtml'] = array(
        '#type' => 'checkbox',
        '#title' => t('Output valid XHTML'),
        '#default_value' => variable_get('beautify_htmltidy_valid_xhtml', 1),
      );
      $form['options']['beautify_htmltidy_warnings'] = array(
        '#type' => 'checkbox',
        '#title' => t('Append errors'),
        '#default_value' => variable_get('beautify_htmltidy_warnings', 0),
      );
      $form['options']['beautify_htmltidy_doctype'] = array(
        '#type' => 'radios',
        '#title' => t('DOCTYPE'),
        '#description' => t('This option specifies the DOCTYPE declaration generated by Tidy.'),
        '#options' => array(
          'omit' => '<strong>Omit</strong>: the output won\'t contain a DOCTYPE declaration',
          'auto' => '<strong>Auto</strong>: Use an educated guess based upon the contents of the document',
          'strict' => '<strong>Strict</strong>: set the DOCTYPE to the strict DTD',
          'transitional' => '<strong>Transitional</strong>: set the DOCTYPE to the transitional (loose) DTD',
          'theme' => '<strong>Theme</strong>: Use the existing DOCTYPE from the theme (page.tpl.php file)',
        ),
        '#default_value' => variable_get('beautify_htmltidy_doctype', 'theme'),
      );
      $form['options']['msword'] = array(
        '#type' => 'fieldset',
        '#title' => t('Clean MS Word'),
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
      );
      $form['options']['msword']['beautify_htmltidy_msword_bare'] = array(
        '#type' => 'checkbox',
        '#title' => t('Convert non-breaking spaces to spaces'),
        '#description' => t('This option specifies if Tidy should strip Microsoft specific HTML from Word 2000 documents, and output spaces rather than non-breaking spaces where they exist in the input.'),
        '#default_value' => variable_get('beautify_htmltidy_word_bare', 0),
      );
      $form['options']['msword']['beautify_htmltidy_word_2000'] = array(
        '#type' => 'checkbox',
        '#title' => t('Strip MS Word 2000 HTML'),
        '#description' => t('This option specifies if Tidy should go to great pains to strip out all the surplus stuff Microsoft Word 2000 inserts when you save Word documents as "Web pages". Doesn\'t handle embedded images or VML. You should consider using Word\'s "Save As: Web Page, Filtered".'),
        '#default_value' => variable_get('beautify_htmltidy_word_2000', 0),
      );
      $form['options']['msword']['beautify_htmltidy_word_attributes'] = array(
        '#type' => 'checkbox',
        '#title' => t('Strip proprietary attributes'),
        '#description' => t('This option specifies if Tidy should strip out proprietary attributes, such as MS data binding attributes.'),
        '#default_value' => variable_get('beautify_htmltidy_word_attributes', 0),
      );
      break;

    // htmLawed options
    case 'htmlawed':
      $form['options']['beautify_htmlawed_valid_xhtml'] = array(
        '#type' => 'checkbox',
        '#title' => t('Output valid XHTML'),
        '#description' => t('Output the most valid XHTML possible.'),
        '#default_value' => variable_get('beautify_htmlawed_valid_xhtml', 1),
      );
      $form['options']['beautify_htmlawed_balance_tags'] = array(
        '#type' => 'checkbox',
        '#title' => t('Balance tags'),
        '#description' => t('Balance tags for well-formedness and proper nesting.'),
        '#default_value' => variable_get('beautify_htmlawed_balance_tags', 1),
      );
      $form['options']['beautify_htmlawed_css_expressions'] = array(
        '#type' => 'checkbox',
        '#title' => t('Allow CSS expressions'),
        '#description' => t('Allow dynamic CSS expression by not removing the expression from CSS property values in style attributes. CSS expressions only work in Internet Explorer 5, 6 and 7.'),
        '#default_value' => variable_get('beautify_htmlawed_css_expressions', 0),
      );
      $form['options']['beautify_htmlawed_keep_bad'] = array(
        '#type' => 'radios',
        '#title' => t('Bad tags'),
        '#description' => t('Neutralize bad tags by converting < and > to entities, or remove them.'),
        '#options' => array(
          0 => 'Remove',
          1 => 'Neutralize both tags and element content',
          2 => 'Remove tags but neutralize element content',
          3 => 'Neutralize both tags and element content but remove if text is invalid in parent element',
          4 => 'Remove tags but neutralize element content but remove if text is invalid in parent element',
          5 => 'Neutralize both tags and element content but line-breaks, tabs and spaces are left',
          6 => 'Remove tags but neutralize element content but line-breaks, tabs and spaces are left',
        ),
        '#default_value' => variable_get('beautify_htmlawed_keep_bad', 2),
      );
      $form['options']['beautify_htmlawed_strict_tags'] = array(
        '#type' => 'radios',
        '#title' => t('Strict tags'),
        '#description' => t('Transform/remove these non-strict XHTML elements, even if they are allowed by the admin: &lt;applet&gt;, &lt;center&gt;, &lt;dir&gt;, &lt;embed&gt;, &lt;font&gt;, &lt;isindex&gt;, &lt;menu&gt;, &lt;s&gt;, &lt;strike&gt;, &lt;u&gt;.'),
        '#options' => array(
          0 => 'No',
          1 => 'Yes, but leave applet, embed and isindex elements that currently can\'t be transformed',
          2 => 'yes, removing applet, embed and isindex elements and their contents (nested elements remain)'
        ),
        '#default_value' => variable_get('beautify_htmlawed_strict_tags', 1),
      );
      $form['options']['beautify_htmlawed_clean_msword'] = array(
        '#type' => 'radios',
        '#title' => t('Clean MS Word'),
        '#description' => t('Replace discouraged characters introduced by Microsoft Word, etc.'),
        '#options' => array(
          0 => 'No',
          1 => 'Yes',
          2 => 'Yes, plus replace special single & double quotes with ordinary ones'),
        '#default_value' => variable_get('beautify_htmlawed_clean_msword', 0),
      );
      $form['options']['beautify_htmlawed_comments'] = array(
        '#type' => 'radios',
        '#title' => t('Comment handling'),
        '#options' => array(
          0 => 'Don\'t consider comments as markup and proceed as if plain text',
          1 => 'Remove',
          2 => 'Allow, but neutralize any &lt;, &gt;, and &amp; inside by converting to named entities',
          3 => 'Allow'),
        '#default_value' => variable_get('beautify_htmlawed_comments', 3),
      );
      break;
  }

  return system_settings_form($form);
}

/**
 * Calculate the available methods.
 */
function beautify_methods() {
  // Always add the built-in method since this should always be available.
  $methods->methods = array('builtin' => 'Built-in');
  // If HTML Tidy is found, add that method.
  if (beautify_htmltidy_test()) {
    $methods->methods += array('htmltidy' => 'HTMLTidy');
  }
  // If htmlLawed is found, add that method.
  $path = drupal_get_path('module', 'beautify');
  if (file_exists($path .'/htmLawed.php')) {
    $methods->methods += array('htmlawed' => 'htmLawed');
  }

  // Stash the current active method.
  $methods->default = variable_get('beautify_method', 'builtin');
  // Get the available options for the active method.
  $methods->options = beautify_get_options();
  // Get the active option for this method.
  $methods->mode = $mode = variable_get('beautify_mode', 2);

  // If the active method is not one of the available options...
  if (!isset($methods->options[$mode])) {
    // Set the mode
    $options = array_keys($methods->options);
    $methods->mode = $options[0];
    variable_set('beautify_mode', $options[0]);
  }

  return $methods;
}

/**
 * Returns options avilable to the active mode.
 */
function beautify_get_options() {
  $options = array(
    1  => 'Beautify',
    -1 => 'Compact',
    2  => 'Flatten',
  );
  // No Beautify option available for built-in method.
  if (variable_get('beautify_method', 'builtin') == 'builtin') {
    unset($options[1]);
  }
  // No Flatten option available for htmLawed method.
  if (variable_get('beautify_method', 'builtin') == 'htmlawed') {
    unset($options[2]);
  }

  return $options;
}

/**
 * Start the output buffering.
 */
function beautify_init() {
  if (variable_get('beautify_enabled', 1)) {
    // Ensure we are not serving a cached page.
    if (function_exists('drupal_set_content')) {
      ob_start();
    }
  }
}

/**
 * Flush the output buffer and send the contents to the router for processing.
 * 
 * This hook will run Tidy twice if debug mode is enabled to get the line
 * numbers right on debug messages (this is highly recommendeded if the site
 * has enough CPU power).
 */
function beautify_exit($destination = NULL) {
  if (variable_get('beautify_enabled', 1)) {
    // Ensure we are not serving a cached page.
    if (function_exists('drupal_set_content') && $destination == NULL) {
      $input = ob_get_contents();
      ob_end_clean();

      // Send the output to the router for processing.
      beautify_router($input);
    }
  }
}

/**
 * Route the buffered output to the active processing routine.
 *
 * The active mode is used to process the output and then set to the page
 * cache. It is then printed to the screen to be displayed on the first
 * subsequent page load. From then on it should be retreived from the
 * page cache.
 *
 * @param $input
 *   The buffered output to be processed.
 */
function beautify_router($input) {
  global $user;
  // We don't want to do anything if the user is authenticated since this has
  // been causing problems with node/add etc.
  if ($user->uid) {
    print $input;
    return;
  }
  $processor = variable_get('beautify_method', 'builtin');
  $mode = variable_get('beautify_mode', 2);
  switch ($processor) {
    case 'builtin':
      $output = beautify_process($input, $mode);
      break;
    case 'htmlawed':
      $output = beautify_htmlawed_process($input);
      break;
    case 'htmltidy':
      $output = beautify_htmltidy_process($input);
      break;
  }

  beautify_set_cache($output);
  print $output;
}

/**
 * Set the processed HTML to the page cache.
 *
 * This attempts to override the page_set_cache(). There could be a better way
 * to do this. Suggestions welcome!
 */
function beautify_set_cache($input) {
  global $user, $base_root;
  if (!$user->uid && $_SERVER['REQUEST_METHOD'] == 'GET' && page_get_cache(TRUE)) {
    // This will fail in some cases, see page_get_cache() for the explanation.
    $cache = TRUE;
    if (variable_get('page_compression', TRUE) && function_exists('gzencode')) {
      // We do not store the data in case the zlib mode is deflate.
      // This should be rarely happening.
      if (zlib_get_coding_type() == 'deflate') {
        $cache = FALSE;
      }
      else if (zlib_get_coding_type() == FALSE) {
        $input = gzencode($input, 9, FORCE_GZIP);
      }
      // The remaining case is 'gzip' which means the data is
      // already compressed and nothing left to do but to store it.
    }

    if ($cache && $input) {
      cache_set($base_root . request_uri(), $input, 'cache_page', CACHE_TEMPORARY, drupal_get_headers());
    }
  }
}

/**
 * Process whatever we are given and return the HTML Tidy response
 * The output and warnings will be returned as arrays by reference.
 *
 * @param $input
 *   html string to be tidied
 * @param $errors
 *   an array to be filled with error info
 * @param $warnings
 *   an array to be filled with warning info
 * @return
 *   the tidied string
 */
function beautify_htmltidy_command($input, &$errors, &$warnings) {
  $path = variable_get('beautify_htmltidy_path', drupal_get_path('module', 'beautify') . '/bin/tidy' . (strpos(PHP_OS, 'WIN' === 0) ? '.exe' : ''));
  if (!file_exists($path)) {
    $message = t("Couldn't find the Tidy binary at '%path', not using tidy.", array('%path' => $path));
    watchdog('beautify', $message, WATCHDOG_WARNING);
    $errors[] = $message;
    return;
  }

  /*
   * Do not pass the parameters their default values as defined in the
   * documentation for tidy (http://www.w3.org/People/Raggett/tidy/), or weird
   * stuff starts to happen.
   */
   // Output Valid XHMTL
  $args[] = '--output-xhtml '. variable_get('beautify_htmltidy_valid_xhtml', 1);
  // Choose DOCTYPE method - if out user based "Theme" option is set we need to
  // do some additional processing.
  if (variable_get('beautify_htmltidy_doctype', 'auto') == 'theme') {
    $args[] = '--doctype omit';
    $document = beautify_parse_html($input);
    $doctype = $document->dtd ."\n";
  }
  else {
    $args[] = '--doctype '. variable_get('beautify_htmltidy_doctype', 'auto');
  }
  // If mode is set to Beautify we need to set indentation to auto. Yes is not
  // recommended in the Tidy reference.
  if (variable_get('beautify_mode', 2) == 1)                  $args[] = '--indent auto';
  // TODO: Add these options to the settings page.
  if (!variable_get('beautify_htmltidy_verbose', 0))          $args[] = '-q';
  if (!variable_get('beautify_htmltidy_wrapphp', 0))          $args[] = '--wrap-php no';
  if (variable_get('beautify_htmltidy_clean', 0))             $args[] = '--clean yes';
  if (variable_get('beautify_htmltidy_enclosetext', 0))       $args[] = '--enclose-text yes';
  if (variable_get('beautify_htmltidy_encloseblocktext', 0))  $args[] = '--enclose-block-text yes';
  // Clean MS Word
  $args[] = '--bare '. variable_get('beautify_htmltidy_word_bare', 0);
  $args[] = '--word-2000 '. variable_get('beautify_htmltidy_word_2000', 0);
  $args[] = '--drop-proprietary-attributes '. variable_get('beautify_htmltidy_word_attributes', 0);
  // User specified configuration file
  $conf = variable_get('htmltidy_confpath', '');
  if (file_exists($conf)) {
    $args[] = '--config '. $conf;
  }
  // Don't add a meta tag with the Tidy info.
  $args[] = '--tidy-mark no';
  // Don't wrap output - this looks terrible so we always set this to off.
  $args[] = '-wrap 0';
  // Output only UTF-8
  $args[] = '-utf8';
  // Modify the input file instead of outputting to stdout.
  $args[] = '-modify';
  // Run the processing with the specified arguments.
  beautify_htmltidy_run($input, $args, $output, $errors = array(), $warnings = array());

/*
  // Output debugging info.
  if (variable_get('htmltidy_warnings', 0) && user_access('use htmltidy debug mode')) {
    $header = "<style type=\"text/css\"> .htmltidy { border: 1px dashed #aaa; background-color: #eee; padding: 1em;\n"
      . "margin: 1em; float: left; font-family: \"courier new\", sans-serif; font-size: 8pt; color: #050; } </style>";
    drupal_set_html_head($header);

    // Run Tidy a second time to get line numbers right.
    if (variable_get('htmltidy_runtwice', 0)) {
      system("$apppath $cline -wrap $wordwrap -utf8 -f $warningsFilename $dirtyFilename");
    }
    $warnings = file_get_contents($warningsFilename);
    drupal_set_message("<h3>HTMLTidy Debug</h3><kbd>$apppath $cline -wrap $wordwrap -utf8 -f $warningsFilename $dirtyFilename</kbd>");
  }
*/

  // Additional processing for beatified output.
  if (variable_get('beautify_mode', 2) == 1) {
    // remove newline from empty script tags
    $output = preg_replace("@(<script[^>]*>)\n(<\/script>)@", '$1$2', $output);
    // add correct indentation for comments inside script tags
    $output = preg_replace("@(<script[^>]*>)\n(<!--)@", "$1\n  $2", $output);
    // add newline and correct indentation for comments immediately following closing script tag
    $output = preg_replace("@(<\/script>)(<!--)@", "$1\n  $2", $output);
    // add newline and correct indentation to opening tags immediately following closing div tag
    $output = preg_replace("@([ ]*)<\/div>(<)@", "$1</div>\n$1$2", $output);
  }

  // Additional processing for flattened output.
  if (variable_get('beautify_mode', 2) == 2) {
    // remove newline from empty script tags
    $output = preg_replace("@(<script[^>]*>)\n(<\/script>)@", '$1$2', $output);
    // add newline comments immediately following closing script tag
    $output = preg_replace("@(<\/script>)(<!--)@", "$1\n$2", $output);
    // remove all leading spaces
    $output = preg_replace('@(\n[ ]*<)@', "\n<", $output);
  }

  return $doctype . $output;
}

function beautify_htmltidy_run($input, $args, &$output, &$errors, &$warnings) {
  $tidypath = variable_get('beautify_htmltidy_path', drupal_get_path('module', 'beautify') . '/bin/tidy' . (strpos(PHP_OS, 'WIN' === 0) ? '.exe' : ''));
  if (!file_exists($tidypath)) {
    watchdog('beautify', 'Failed to find HTML Tidy executable at %beautify_htmltidy_path, not using tidy', array('%beautify_htmltidy_path' => $tidypath), WATCHDOG_WARNING);
    $output = '';
    return 2;
  }

  // write input to a file because tidy doesn't take input from stdin.
  $dirtyFilename = tempnam(file_directory_temp(), 'drup');
  $f = fopen($dirtyFilename, 'w');
  fwrite($f, $input);
  fclose($f);

  // warnings are saved to file
  $warningsFilename = tempnam(file_directory_temp(), 'warn');
  $args[] = '-f ' . $warningsFilename;

  // Run Tidy with the right options.
  $command = $tidypath .' '. implode(' ', $args) .' '. $dirtyFilename;
  system($command, $return_value);

  // return_value 0 means success. 1 means warning. 2 means error, the file
  // will be there, but not have been touched.
  switch ($return_value) {
  case 0:
    $warnings = $errors = array();
    $output = file_get_contents($dirtyFilename);
    break;

  case 1:
    $errors = array();
    $warnings = array_map('trim', file($warningsFilename));
    $output = file_get_contents($dirtyFilename);
    break;

  case 2:
    // separate errors and warnings into two different arrays
    foreach(file($warningsFilename) as $line) {
      $line = trim($line);
      if (preg_match('|^line \d+ column \d+ - Warning:|', $line)) {
        $warnings[] = $line;
      }
      else {
        $errors[] = $line;
      }
    }
    $output = $input;
    break;
  }

  // delete the temporary files.
  unlink($dirtyFilename);
  unlink($warningsFilename);
  return $return_value;
}

/**
 * Calculates a valid path to the HTML Tidy binary.
 *
 * @param $message 
 *   Assigned to an explanation.
 * @return
 *   TRUE if found,
 *   FALSE if error.
 */

function beautify_htmltidy_test(&$message = '', &$version = '') {
	$fail = strpos(PHP_OS, 'WIN') === 0;
	$sub = drupal_get_path('module', 'beautify') . '/bin/tidy' . ($fail ? '.exe' : '');
	$path = variable_get('beautify_htmltidy_path', $sub);
	$test = FALSE;
	if (!@file_exists($path)) {
		// Test for binary in subdirectory first
		if (@file_exists($sub)) {
			$new_path = $sub;
		}
		elseif (!$fail) {
			// Not on Windows, so let's try which
			$which = shell_exec('which tidy');
			if (strpos($which, '/') === 0) {
				$new_path = $which;
			}
		}
		if (isset($new_path)) {
			variable_set('beautify_htmltidy_path', $new_path);
			$path = $new_path;
			$test = TRUE;
		}
		else {	
			$message .= t('Could not find HTML Tidy binary.');
		}
	}
	if ($test) {
	  $command = escapeshellcmd($path .' -v');
	  if (exec($command, $response)) {
	    $version = $response[0];
	    return TRUE;
	  }
	  else {
	    $message .= t('Found an HTML Tidy binary but it didn\'t seem to run properly. !command failed to respond correctly.', 
	                  array('!command' => $command));
	    return FALSE;
	  }
	}
}

/**
 * Parse the HTML document into sections.
 *
 * @param $input
 *   The buffered HTML to parse.
 * @return $output
 *   An object containing:
 *     $html_document->dtd
 *     $html_document->doctype
 *     $html_document->head
 *     $html_document->body
 *     $html_document->bodyattr
 *
 * TODO: For performance reasons make this function accept a string to ask for
 * a specific part of the document. We can still send the whole object by
 * default if still needed.
 */
function beautify_parse_html($input) {
  // DTD
  $regex = '/(.*\.dtd">)/Umsi'; // just the doctype without the html tag.
  preg_match($regex, $input, $matches);
  $output->dtd = $matches[1];

  // DOCTYPE
  $regex = '/(.*<html.*>)/Umsi'; // doctype plus opening html tag with attributes.
  preg_match($regex, $input, $matches);
  isset($matches[1]) && $output->doctype = $matches[1] ."\n";

  // head
  $regex = '@(<head.*>.*</head\\s*>)@Umsi'; // the whole head section
  preg_match($regex, $input, $matches);
  if (isset($matches[1])) {
    $head = trim($matches[1]);
    $replace = array("\n  ", "\n\n");
    $head = str_replace($replace, "\n", $head);
    $output->head = $head ."\n";
  }
  
  // body
  $regex = '@<body(.*)>(.*)</body\\s*>@Umsi'; // the whole body section
  preg_match($regex, $input, $matches);
  if (isset($matches[1]) && trim($matches[1])) {
    $output->bodyattr = trim($matches[1]); // body attributes
  }
  if (isset($matches[2])) {
    $output->body = trim($matches[2]);
  }
  else {
    $output->body = trim($input);
  }

  return $output;
}

/**
 * Built-in processing function for compacting or flattening the output.
 *
 * @param $input
 *   The HTML output to process.
 * @param $mode
 *   The mode of operation defined on beautify_get_options().
 * @return
 *   The processed output.
 */
function beautify_process($input, $mode) {
  switch ($mode) {

    case -1: // Comptact
      preg_match('/(.*)>/Umsi', $input, $matches); // doctype
      $no_doctype = str_replace($matches[0], '', $input);
      $output = preg_replace("@\n\s+@", " ", $no_doctype); // newline and 1 or more spaces
      $output = preg_replace("@\s\s\s+@", " ", $output); // three or more spaces
      $output = preg_replace("@>\n@", "> ", $output); // closing tag marker and a new line
      $output = $matches[0] . $output;
      break;

    case 2: // Flatten
      $output = preg_replace("@\n\s+@", "\n", $input); // a newline and some spaces
      $output = preg_replace("@\s\s+@", "", $output); // two or more spaces
      break;

    default:
      $output = $input;
      break;
  }

  return $output;
}

/**
 * Processeses the HTML document through htmLawed.
 *
 * @param $input
 *   The buffered output to process.
 * @return $output
 *   The processed output.
 */
function beautify_htmlawed_process($input) {
  // Split the document into sections.
  $html_document = beautify_parse_html($input);
  $output = $html_document->doctype;

  // If compact mode is active we need to process the head since htmLawed won't
  // do that for us.
  $mode = variable_get('beautify_mode', 2);
  if ($mode == -1) { // Comptact
    $head = beautify_process($html_document->head, -1) ."\n";
  }
  else {
    $head .= beautify_process($html_document->head, 2) ."\n";
  }

  // Set up the config arguments.
  $config = array(
    'balance' => variable_get('beautify_htmlawed_balance_tags', 1),
    'valid_xhtml' => variable_get('beautify_htmlawed_valid_xhtml', 1),
    'clean_ms_char' => variable_get('beautify_htmlawed_clean_msword', 0),
    'comment' => variable_get('beautify_htmlawed_comments', 3),
    'css_expression' => variable_get('beautify_htmlawed_css_expressions', 0),
    'schemes' => '*:*',
    'make_tag_strict' => variable_get('beautify_htmlawed_strict_tags', 1),
    'keep_bad' => variable_get('beautify_htmlawed_keep_bad', 2),
  );

  // Our modes are slightly different to those accepted by htmLawed.
  if ($mode == 1) {
    $config['tidy'] = 2;
  }
  elseif ($mode == -1) {
    $config['tidy'] = -1;
  }

  // Process the body of the document through htmLawed.
  include 'htmLawed.php';
  $body = htmLawed($html_document->body, $config);

  // Concatenate the separate parts back together.
  $output .= $head .'<body '. $html_document->bodyattr .">\n". trim($body) ."\n</body>\n</html>";

  return $output;
}

/**
 * Process the buffered output through the HTML Tidy processor.
 *
 * @param $input
 *   The buffered output to process.
 * @return $output
 *   The processed output.
 */
function beautify_htmltidy_process($input) {
  $output = beautify_htmltidy_command($input, $errors, $warnings);

  // Merge the errors and warnings together with the errors listed first.
  $errors = array_merge($errors, $warnings);

  // Here we're using HTML Tidy to flatten and then using the built-in comptact routine.
  $mode = variable_get('beautify_mode', 2);
  if ($mode == -1) {
    $output = beautify_process($input, $mode);
  }

  // TODO: Fix output of errors. Not working right now.
  if ($errors && variable_get('beautify_htmltidy_warnings', 0) && user_access('use beautify debug mode')) {
    $errors = array_map('htmlentities', $errors);
    $output .= theme('theme_beautify_htmltidy_errors', $errors);
  }

  return $output;
}

/**
 * Theme function for displaying the errors.
 *
 * @param $errors
 *   An array of errors generated by HTML Tidy.
 * @return $output
 *   The HTML for displaying the errors on the page.
 */
function theme_beautify_htmltidy_errors($errors) {
  $output = '<div class="beautify-errors"><h3>Beautify Errors</h3>';
  $output .= theme('item_list', $errors);
  $output .= '</div>';
  return $output;
}
